import OpenAI from "openai";
import { Uploadable } from "openai/uploads";
import { linaPrompt } from "../linaPrompt";
import { FunctionDefinition } from "openai/resources";
import { UserStory, isUserStory } from "../userStory.type";

type Return = {
  userStories: Array<UserStory>;
  commentsFromAssistant: string;
};
type AskBpmnUserStoryAssistant = (
  openai: OpenAI,
  file: Uploadable
) => Promise<Return>;

export const askBpmnUserStoryAssistant: AskBpmnUserStoryAssistant = async (
  openai,
  file
) => {
  const openaiFile = await openai.files.create({
    file,
    purpose: "assistants",
  });

  const assistant = await openai.beta.assistants.create({
    name: "BPMN to User Story Assistant",
    model: "gpt-4-turbo-preview",
    instructions: linaPrompt,
    tools: [{ function: openaiFunction, type: "function" }],
  });

  const thread = await openai.beta.threads.create();
  await openai.beta.threads.messages.create(thread.id, {
    role: "user",
    content: "Can you generate user stories from this BPMN?",
    file_ids: [openaiFile.id],
  });

  let run = await openai.beta.threads.runs.create(thread.id, {
    assistant_id: assistant.id,
    additional_instructions: `You MUST call the \`${openaiFunction.name}\` function with the user stories you generated. You have to put all the user stories in the \`userStories\` parameter.`,
  });
  const runId = run.id;

  let status:
    | "queued"
    | "in_progress"
    | "requires_action"
    | "cancelling"
    | "cancelled"
    | "failed"
    | "completed"
    | "expired" = "queued";
  while (
    status === "queued" ||
    status === "in_progress" ||
    status === "cancelling"
  ) {
    await new Promise((resolve) => setTimeout(resolve, 5000));
    run = await openai.beta.threads.runs.retrieve(thread.id, runId);
    status = run.status;
    console.log("Status", status);
  }

  const messages = await openai.beta.threads.messages.list(thread.id);
  const commentsFromAssistant =
    messages.data[0].content[0].type === "text"
      ? messages.data[0].content[0].text.value
      : "";
  console.log("Messages", JSON.stringify(messages.data));

  // Clean up
  await openai.files.del(openaiFile.id);
  await openai.beta.assistants.del(assistant.id);
  await openai.beta.threads.del(thread.id);

  console.log("required_action", JSON.stringify(run.required_action));

  const userStories = JSON.parse(
    run.required_action?.submit_tool_outputs.tool_calls[0].function.arguments ||
      "{'userStories': []}"
  )["userStories"];
  if (!userStories.every(isUserStory)) {
    throw new Error("Invalid user stories");
  }

  return { userStories, commentsFromAssistant };
};

const openaiFunction: FunctionDefinition = {
  name: "giveBackUserStories",
  description: "Give back the user stories generated by the assistant",
  parameters: {
    type: "object",
    properties: {
      userStories: {
        type: "array",
        description: "The user stories generated by the assistant",
        items: {
          type: "object",
          properties: {
            title: { type: "string" },
            acceptanceCriteria: {
              type: "array",
              items: { type: "string" },
            },
          },
        },
      },
    },
  },
};
